// Google Apps Script (GAS) Code - BACKUP
// This script is assumed to be deployed as a web app.
// It interacts with a Google Spreadsheet to store and retrieve data for the LINGUAPORTA extension.

// --- Configuration ---
// Replace with your Google Spreadsheet ID
const SPREADSHEET_ID = "YOUR_SPREADSHEET_ID"; 

// Sheet names
const DB_SHEET_NAME = "QuestionDB";
const PORTFOLIO_SHEET_NAME = "PortfolioLog";
const RESULT_SHEET_NAME = "ResultLog";

/**
 * Handles POST requests from the Chrome extension's background script.
 * This is the main entry point for the web app.
 * @param {Object} e - The event parameter containing the POST request data.
 * @returns {ContentService.TextOutput} - A JSON response.
 */
function doPost(e) {
  let response;
  try {
    const payload = JSON.parse(e.postData.contents);
    const requestType = payload.request_type;

    switch (requestType) {
      case "get":
        response = handleGetRequest(payload);
        break;
      case "set":
        response = handleSetRequest(payload);
        break;
      case "portfolio_record":
        response = handlePortfolioRecord(payload);
        break;
      case "result_setting_record":
        response = handleResultRecord(payload);
        break;
      default:
        response = { status: "error", message: "Invalid request_type" };
        break;
    }
  } catch (error) {
    response = { status: "error", message: "An error occurred: " + error.message, stack: error.stack };
  }

  return ContentService.createTextOutput(JSON.stringify(response))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Handles retrieving question answers from the spreadsheet.
 * @param {Object} payload - The request payload.
 * @returns {Object} - The response object.
 */
function handleGetRequest(payload) {
  const questionNumbers = payload.question_number;
  if (!questionNumbers || !Array.isArray(questionNumbers)) {
    return { status: "error", message: "Invalid or missing question_number array" };
  }

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(DB_SHEET_NAME);
  if (!sheet) {
    return { status: "error", message: `Sheet "${DB_SHEET_NAME}" not found.` };
  }
  
  const data = sheet.getDataRange().getValues();
  const header = data[0];
  const questionNumberColIndex = header.indexOf("question_number");

  const results = [];
  const questionSet = new Set(questionNumbers);

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const qNum = row[questionNumberColIndex];
    if (questionSet.has(qNum)) {
      results.push(row);
    }
  }

  return { status: "success", content: results };
}

/**
 * Handles setting (saving) new question answers to the spreadsheet.
 * @param {Object} payload - The request payload.
 * @returns {Object} - The response object.
 */
function handleSetRequest(payload) {
  const content = payload.content;
  if (!content || !Array.isArray(content)) {
    return { status: "error", message: "Invalid or missing content array" };
  }

  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(DB_SHEET_NAME);
  if (!sheet) {
    return { status: "error", message: `Sheet "${DB_SHEET_NAME}" not found.` };
  }

  const data = sheet.getDataRange().getValues();
  const header = data[0];
  const questionNumberColIndex = header.indexOf("question_number");
  
  const existingQuestionNumbers = new Set(data.slice(1).map(row => row[questionNumberColIndex]));

  const rowsToAdd = [];
  content.forEach(item => {
    if (!existingQuestionNumbers.has(item.question_number)) {
      // Assuming the order of columns in the sheet matches the object properties
      const newRow = [
        new Date(), // timestamp
        payload.id, // user_id
        item.question_number,
        item.question_type,
        item.question_answer_1,
        item.question_answer_2,
        null, // Placeholder for other columns if any
        null
      ];
      rowsToAdd.push(newRow);
      existingQuestionNumbers.add(item.question_number); // Avoid duplicates in the same batch
    }
  });

  if (rowsToAdd.length > 0) {
    sheet.getRange(sheet.getLastRow() + 1, 1, rowsToAdd.length, rowsToAdd[0].length).setValues(rowsToAdd);
  }

  return { status: "success", message: `${rowsToAdd.length} new questions added.` };
}

/**
 * Handles recording portfolio (learning summary) data.
 * @param {Object} payload - The request payload.
 * @returns {Object} - The response object.
 */
function handlePortfolioRecord(payload) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(PORTFOLIO_SHEET_NAME);
  if (!sheet) {
    return { status: "error", message: `Sheet "${PORTFOLIO_SHEET_NAME}" not found.` };
  }

  const newRow = [
    new Date(), // timestamp
    payload.id,
    payload.score,
    payload.rank,
    payload.challenge_times,
    payload.learning_time
  ];
  sheet.appendRow(newRow);

  return { status: "success", message: "Portfolio recorded." };
}

/**
 * Handles recording result/setting data for analytics.
 * @param {Object} payload - The request payload.
 * @returns {Object} - The response object.
 */
function handleResultRecord(payload) {
  const sheet = SpreadsheetApp.openById(SPREADSHEET_ID).getSheetByName(RESULT_SHEET_NAME);
  if (!sheet) {
    return { status: "error", message: `Sheet "${RESULT_SHEET_NAME}" not found.` };
  }

  const newRow = [
    new Date(), // timestamp
    payload.id,
    payload.version,
    payload.set_score,
    payload.set_late,
    payload.set_wrong_question,
    payload.set_run_unit,
    payload.run_unit,
    payload.run_question_number,
    payload.get_score,
    payload.incorrect_answer_times,
    payload.duration,
    payload.browser,
    payload.os,
    payload.screen_width,
    payload.screen_height,
    payload.user_agent
  ];
  sheet.appendRow(newRow);

  return { status: "success", message: "Result recorded." };
}